# TDD

## 학습 키워드

- [x] TDD란
- [x] Jest
- [x] Describe - Context - It 패턴
- [x] 단위테스트란

## 테스트를 한다는 것은

정말 유능한 개발자가 되려면 기능 구현도 중요하지만 테스트 작성을 잘해야 한다.

그렇다면 테스트를 한다는 것이 무엇을 의미하는지 생각해보자

1. 제품이나 서비스의 품질을 확인하는 것
2. 소프트웨어의 버그를 찾는 것

_⇒ 결국 테스트는 애플리케이션이 원하는 대로 동작하는지 확인하는 것이다 !_

---

보통 일반적인 개발방식은 **설계를 하고 코드 개발을 하고 테스트를 하는 방식**으로 진행된다고 한다.

그런데 설계한대로 코드 개발을 하고 기능 구현을 해냈다고 치자.

후에 테스트 했을 때 예상한대로 동작하지 않아서 처음부터 다시 설계를 하고 코드를 짜야 한다면 매우 혼란스러울 것이다. 그렇다고 처음부터 설계를 빈틈없이 완벽히 하는 것도 어려운 일이다.

이러한 일반적인 개발 방식의 문제점을 보완하고자 우리는 TDD 개발 방식을 이용한다.

## TDD란?

> 테스트 코드를 먼적 작성하고, 구현보다 인터페이스(기능, 명세)와 스펙을 먼저 정의함으로써 개발을 진행하는 방식

### TDD 개발방법을 사용해야하는 이유 ?!

- 필요한 만큼만 코드를 작성할 수 있다.
- 설계에 대한 피드백을 빨리 할 수 있다.
- 모든 요구 사항에 대해 점검이 가능하고 사용자 입장에서 코드를 작성하는 것이 가능하다
- 구현보다는 인터페이스에 집중하므로 코드의 전체적인 퀄리티가 향상될 수 있다.

### TDD Cycle(Tdd로 테스트 코드 작성하는 법)

1. Red : 실패하는 테스트 코드를 작성한다. 인터페이스와 스펙에 집중

2. Green : 실패하는 테스트 코드를 통과시킨다. 뭐라도 괜찮으니 일단 빨리 만든다.

3. Refactor : 리팩터링을 통해 코드를 올바르게 만든다. 일단은 제대로 작동한다는 전제하에 코드를 깔끔하게 만드는 것.(중요)

이 사이클을 도는 것을 10분 안에 할 수 있다면 좋다.

작은 단계를 찾고, 코드에서 피드백을 얻는 게 (어렵고) 중요하다. 2번이 어렵다면 1번으로 돌아가서 더 작고 쉬운 문제를 정의하고, 3번을 위해 의도를 드러내고 중복을 찾아 제거하는 연습을 해야 한다. 이 둘이 익숙하지 않으면 TDD를 하는 게 거의 불가능하고, 사실 이 둘이 어려우면 일반적인 개발 또는 클린 코드를 작성하는 것 또한 매우 힘들다.

## jest란?

> Jest는 페이스북에서 만든 단순함에 초점을 맞춘 자바스크립트 테스트 프레임워크이다.

### jest 용어 정리

- describe()

  여러 개의 test()코드를 하나의 테스트 작업 단위로 묶어준다.

- test()

  테스트 코드를 돌리기 위한 API, 하나의 테스트 케이스를 의미하고 it()으로 쓸 수도 있다.

- expect()

  인자로는 테스트할 대상을 넣고, 기대 값 등을 뒤에 메서드 체이닝으로 넣어준다.

- beforeEach()

  테스트 파일의 테스트 코드가 돌기 전에 수행할 로직을 넣어준다. 테스트 케이스마다 반복되는 로직이 있는 경우 사용하면 유용하다.

보통 Jest로 테스트 케이스를 정의할 때 test 함수로 "개별 테스트를 나열"하거나 "BDD 스타일로 주체-행위 중심으로 테스트를 조직화"한다.

## 개별 테스트 나열

```javascript
test("add", () => {
  expect(add(1, 2)).toBe(3);
});
```

## Describe - Context - It 패턴

- Describe : 설명할 테스트 대상(클래스나 메소드, 함수명)
- Context : 테스트 대상이 놓인 상황 설명(메소드에 입력할 파라미터, 문장 앞에 when/with 자주 사용)
- it: 테스트 대상의 행동을 설명(메소드의 리턴값 설명)

BDD(Behavior Driven Development) 테스트 코드 작성 패턴인 Given-When-Then 스타일과 비슷하지만 테스트 대상의 행동을 더 자세하게 설명하는 패턴이다.

### add 함수 예시

```javascript
function add(...numbers: number[]): number {
  if (!numbers.length === 0) {
    return 0;
  }
  if (numbers.length === 1) {
    return numbers[0];
  }
  if (numbers.length === 2) {
    return numbers[0] + number[i];
  }
  if (numbers.length === 3) {
    return add(numbers[0], numbers[1]) + numbers[2];
  }
}

const context = describe;

test("add", () => {
  expect(add(1, 2)).toBe(3);
});

// add 메서드가 테스트 대상임(함수명)
describe("add", () => {
  //테스트 대상이 놓인 상황(인자의 개수)
  context("with no argument", () => {
    // 테스트 대상의 행동(리턴값)
    it("return zero", () => {
      expect(add()).toBe(0);
    });
  });

  context("with only one argument", () => {
    it("returns the same number", () => {
      expect(add(2)).toBe(2);
    });
  });

  context("with two arguments", () => {
    it("return sum of two numbers", () => {
      expect(add(1, 2)).toBe(3);
    });
  });

  context("with three arguments", () => {
    it("returns sum of three numbers", () => {
      expect(add(1, 2, 3)).toBe(6);
    });
  });
});
```

jest 계속 켜놓는 명령어

```
npx jest --watchAll
```

## 테스트 피라미드

![테스트 피라미드](/images/test-pyramid.png)

테스트는 범위 별로 단위 테스트, 통합 테스트, 사용자 테스트(end-to-end)로 나뉜다.

- 단위 테스트(unit test) : 함수, 모듈, 클래스
- 통합 테스트(integration test) : 모듈들, 클래스들
- E2E 테스트(end-to-end) : 사용자 테스트, UI 테스트

피라미드의 위쪽으로 올라갈수록 테스트 비용이 올라가고 테스트 속도가 느리다.

단위 테스트를 작성하는 것이 가장 싸고 쉽고 속도도 빠르므로 많이 작성하는 것이 좋다.

그래야 더 빠르게 내 코드에 문제가 없는지 피드백할 수 있기 때문이다.

## 단위 테스트

> 단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트이다.

단위 테스트는 일반적으로 함수, 메서드, 클래스 수준을 테스트하는 것이다.
어떤 기능이 실행되면 어떤 결과가 나온다 정도로 테스트를 진행한다.

### 단위 테스트 작성의 필요성

단위 테스트는 애플리케이션의 작은 부분만 독립적으로 테스트 하므로 빠르게 문제 여부를 확인할 수 있다.

그리고 사실 테스트 코드를 통해 문서화도 가능하다 !

모든 함수에 대해 단위 테스트를 진행하므로 테스트 코드를 잘 작성하는 것만으로 개발자의 의도를 더욱 명확히 알 수 있다.

## 좋은 테스트란?

> 📌 **F (Fast) I (Isolated) R (Repeatable), S (Self - Validating), T (Timely)**

좋은 테스트의 FIRST 법칙이 있다.

**Fast**: 실행 속도가 빨라야 한다. 느린 것에 대한 의존성 낮추어야 한다. 예를 들어 파일, 데이터베이스, 네트워크 등 실행 속도를 느려지게 하는 부분에서 mock 함수를 사용하면 좋다

**Isolated** : 독립적이고 집중적으로 유지해야 한다.

**Repeatable** : 코드가 변하지 않았다면 테스트 결과는 항상 동일 해야 한다. 다른 테스트 코드에 의존하거나 네트워크에 의존하면 좋지 않다. 환경에 영향을 받지 않도록 작성하는 것이 좋다.

**Self - Validating** : 스스로 결과를 검증하기

**Timely** : 시기적절하게 테스트 코드 작성하기

이외에도 버그를 찾을 수 있어야 하고 테스트 결과에 일관성이 있으며 의도가 명확히 드러난 테스트 코드가 좋은 테스트이다.
